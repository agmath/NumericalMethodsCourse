---
title: "MAT 370: Least Squares Regression"
author: Dr. Gilbert
format: 
  revealjs:
    smaller: true
date: today
date-format: long
theme: serif
incremental: true
execute: 
  error: true
---

```{r global-options, include=FALSE}
library(tidyverse)
library(reticulate)

theme_set(theme_bw(base_size = 20))
```

```{python}
import numpy as np
import matplotlib.pyplot as plt
import time

def GaussElim(A, b):
  n = len(b)

  for k in range(0, n-1):
    for i in range(k+1, n):
      if A[i, k] != 0.0:
        lam = A[i, k]/A[k, k]
        A[i, k:n] = A[i, k:n] - lam*A[k, k:n]
        b[i] = b[i] - lam*b[k]

  for k in range(n - 1, -1, -1):
    b[k] = (b[k] - np.dot(A[k, (k+1):n], b[(k+1):n]))/A[k,k]

  return b

def LUdecomp(A):
  n = A.shape[0]
  for k in range(n):
    for i in range(k+1, n):
      if A[i, k] != 0.0:
        lam = A[i, k]/A[k, k]
        A[i, (k+1):n] = A[i, (k+1):n] - lam*A[k, (k+1):n]
        A[i, k] = lam

  return A

def LUsolve(LU, b):
  n = len(b)
  for k in range(1, n):
    b[k] = (b[k] - np.dot(LU[k, 0:k], b[0:k]))

  b[n-1] = b[n-1]/LU[n-1, n-1]

  for k in range(n-2, -1, -1):
    b[k] = (b[k] - np.dot(LU[k, (k+1):n], b[(k+1):n]))/LU[k, k]

  return b

def DoolittleLUsolver(A, b):
  LU = LUdecomp(A) #Row Reduction
  sol = LUsolve(LU, b) #Forward/backward substitution

  return sol

def DoolittleLUdecomp3(c, d, e):
  n = len(d)
  for k in range(1, n):
    lam = c[k-1]/d[k-1]
    d[k] = d[k] - lam*e[k-1]
    c[k-1] = lam

  return c, d, e

def Doolittle3solver(lam, d, e, b):
  n = len(d)
  for k in range(1, n):
    b[k] = b[k] - lam[k-1]*b[k-1]

  b[n-1] = b[n-1]/d[n-1]
  for k in range(n-2, -1, -1):
    b[k] = (b[k] - e[k]*b[k+1])/d[k]

  return b

def DoolittleLUdecomp3solver(c, d, e, b):
  lam, d, e = DoolittleLUdecomp3(c, d, e)
  b = Doolittle3solver(lam, d, e, b)

  return b

def swapRows(v, i, j):
  if len(v.shape) == 1:
    v[i], v[j] = v[j], v[i]
  else:
    v[[i, j], :] = v[[j, i], :]

def scaleFactors(A):
  n = A.shape[0]
  s = np.zeros(n)
  for i in range(n):
    s[i] = max(np.abs(A[i, :]))

  return s

def gaussPivot(A, b, tol = 1.0e-12):
  n = len(b)
  s = scaleFactors(A)

  for k in range(0, n-1):
    p = np.argmax(np.abs(A[k:n, k])/s[k:n]) + k
    if(abs(A[p, k]) < tol):
      print("Matrix is Singular")
      return None

    #Row Pivot if necessary
    if p != k:
      swapRows(b, k, p)
      swapRows(s, k, p)
      swapRows(A, k, p)

    #Elimination
    for i in range(k+1, n):
      if A[i, k] != 0.0:
        lam = A[i, k]/A[k, k]
        A[i, (k+1):n] = A[i, (k+1):n] - lam*A[k, (k+1):n]
        b[i] = b[i] - lam*b[k]

  if abs(A[n-1, n-1]) < tol:
    print("Matrix is Singular")
    return None

  #back substitution
  b[n-1] = b[n-1]/A[n-1, n-1]
  for k in range(n-2, -1, -1):
    b[k] = (b[k] - np.dot(A[k, (k+1):n], b[(k+1):n]))/A[k, k]

  return b

def getCoefficients(xData, yData):
  m = len(xData)
  a = yData.copy()

  for k in range(1, m):
    a[k:m] = (a[k:m] - a[k-1])/(xData[k:m] - xData[k-1])

  return a

def evaluatePolynomial(a, xData, x):
  deg = len(xData) - 1
  p = a[deg]

  for k in range(1, deg + 1):
    p = a[deg-k] + (x - xData[deg-k])*p

  return p

def curvatures(xData, yData):
  n = len(xData) - 1
  c = np.zeros(n)
  d = np.ones(n+1)
  e = np.zeros(n)
  k = np.zeros(n+1)

  c[0:(n-1)] = xData[0:(n-1)] - xData[1:n]
  d[1:n] = 2.0*(xData[0:(n-1)] - xData[2:(n+1)])
  e[1:n] = xData[1:n] - xData[2:(n+1)]
  k[1:n] = 6.0*((yData[0:(n-1)] - yData[1:n])/(xData[0:(n-1)] - xData[1:n])) - 6.0*((yData[1:n] - yData[2:(n+1)])/(xData[1:n] - xData[2:(n+1)]))

  #DoolittleLUdecomp3(c, d, e)
  DoolittleLUdecomp3solver(c, d, e, k)

  return k

def findSegment(xData, x):
    iLeft = 0
    iRight = len(xData) - 1

    while 1:
      if (iRight - iLeft) <= 1:
        return iLeft
      i = int((iLeft + iRight)/2)
      if x < xData[i]:
        iRight = i
      else:
        iLeft = i

def evalSpline(xData, yData, k, x):
  i = findSegment(xData, x)
  h = xData[i] - xData[i+1]
  y = ((x - xData[i+1])**3/h - (x - xData[i+1])*h)*k[i]/6.0 - ((x - xData[i])**3/h - (x - xData[i])*h)*k[i+1]/6.0 + (yData[i]*(x - xData[i+1]) - yData[i+1]*(x - xData[i]))/h
  y = ((x - xData[i+1])**3/h - (x - xData[i+1])*h)*k[i]/6.0 - ((x - xData[i])**3/h - (x - xData[i])*h)*k[i+1]/6.0 + (yData[i]*(x - xData[i+1]) - yData[i+1]*(x - xData[i]))/h


  return y
```

```{css}
code.sourceCode {
  font-size: 1.3em;
  /* or try font-size: xx-large; */
}

a {
  color: purple;
}

a:link {
  color: purple;
}

a:visited {
  color: purple;
}
```

## Motivation and Context

<div style="font-size:18pt">

:::{.fragment}

You've spent lots of time over your life solving equations.

:::

:::{.fragment}

At times, it may have felt like you were being asked to memorize "tricks" (though I hope that's not the case).

:::

::::{.columns}

:::{.column width="50%"}

:::{.fragment}

You've learned how to solve

:::

+ Linear equations
+ Quadratic equations
+ General polynomial equations
+ Rational equations
+ Exponential equations
+ Logarithmic equations
+ Trigonometric equations
+ And more...

:::

:::{.column width="50%"}

:::{.fragment}

Unfortunately, no matter how good you are with algebraic techniques, they'll fail you.

:::

:::{.fragment}

Try solving the equation $\displaystyle{\frac{x^2 - 9}{x + 4}e^x = 10\sin\left(x\right)}$

:::

:::{.fragment}

No combination of algebraic techniques will permit you to find a solution.

:::

:::{.fragment}

If we reframe the equation as a root-finding problem -- that is, find the root of the function $\displaystyle{f\left(x\right) = \frac{x^2 - 9}{x + 4}e^x - 10\sin\left(x\right)}$, then some additional tools become available to us.

:::

:::

::::

:::{.fragment}

**Main Takeaway:** Any equation, $\boxed{~\displaystyle{\text{expression_1} = \text{expression_2}}~}$ can be reframed as a root-finding question for the function $\boxed{~\displaystyle{f\left(x\right) = \text{expression_1} - \text{expression_2}}~}$

:::

</div>

## When Do Functions Have Roots?

:::{.fragment}

We need a method to determine whether a root exists on an interval. We'll start with some pictures.

:::

:::{.fragment}

```{python}
x_vals = np.linspace(0, 10, 250)
y_vals = np.sin(x_vals)

x0a = 2
y0a = np.sin(x0a)
x1a = 4
y1a = np.sin(x1a)

x0b = 4
y0b = np.sin(x0b)
x1b = 6
y1b = np.sin(x1b)

plt.figure(figsize = (12, 4))

plt.subplot(1,2,1)
plt.plot(x_vals, y_vals, color = "purple")
plt.scatter([x0a, x1a], [y0a, y1a], color = "black", s = 100)
plt.grid()
plt.axhline(y = 0, color = "black")
plt.axvline(x = 0, color = "black")
plt.xlabel("x")
plt.ylabel("y")
plt.title("A Root Exists Between $x_0 = 2$ and $x_1 = 4$ Due to \nthe Sign Change in Function Values")

plt.subplot(1,2,2)
plt.plot(x_vals, y_vals, color = "purple")
plt.scatter([x0b, x1b], [y0b, y1b], color = "black", s = 100)
plt.grid()
plt.axhline(y = 0, color = "black")
plt.axvline(x = 0, color = "black")
plt.xlabel("x")
plt.ylabel("y")
plt.title("A Root May Not Exist Between $x_0 = 4$ and $x_1 = 6$ Since \nno Sign Change in Function Values")
plt.show()
```

:::

## When Do Functions Have Roots?

We need a method to determine whether a root exists on an interval. We'll start with some pictures.

```{python}
x_vals = np.linspace(0, 10, 250)
y1_vals = np.sin(x_vals)
y2_vals = np.sin(5*x_vals)
y3_vals = np.tan(x_vals)

x0 = 2
y0 = np.sin(x0)
x1 = 4
y1 = np.sin(x1)

plt.figure(figsize=(20, 10))
plt.subplot(2, 2, 1)
plt.plot(x_vals, y1_vals, color = "purple", linewidth = 3)
plt.scatter([x0, x1], [y0, y1], color = "black", s = 150)
plt.xlabel("x")
plt.ylabel("y")
plt.title("Sign Change: One Root", fontsize=18)
plt.grid()
plt.axhline(y = 0, color = "black")
plt.axvline(x = 0, color = "black")

x0 = 2
y0 = np.sin(5*x0)
x1 = 4
y1 = np.sin(5*x1)
plt.subplot(2, 2, 2)
plt.plot(x_vals, y2_vals, color = "purple", linewidth = 3)
plt.scatter([x0, x1], [y0, y1], color = "black", s = 150)
plt.xlabel("x")
plt.ylabel("y")
plt.title("Sign Change: Many Roots", fontsize = 18)
plt.grid()
plt.axhline(y = 0, color = "black")
plt.axvline(x = 0, color = "black")

x0 = 4
y0 = np.tan(x0)
x1 = 6
y1 = np.tan(x1)
plt.subplot(2, 2, 3)
plt.plot(x_vals[:30], y3_vals[:30], color = "purple", linewidth = 3)
plt.plot(x_vals[50:110], y3_vals[50:110], color = "purple", linewidth = 3)
plt.plot(x_vals[120:190], y3_vals[120:190], color = "purple", linewidth = 3)
plt.plot(x_vals[200:250], y3_vals[200:250], color = "purple", linewidth = 3)
plt.scatter([x0, x1], [y0, y1], color = "black", s = 150)
plt.xlabel("x")
plt.ylabel("y")
plt.title("Sign Change: No Roots", fontsize = 18)
plt.grid()
plt.axhline(y = 0, color = "black")
plt.axvline(x = 0, color = "black")
plt.ylim((-2, 2));

x0 = 2
y0 = np.sin(x0)
x1 = 8
y1 = np.sin(x1)
plt.subplot(2, 2, 4)
plt.plot(x_vals, y1_vals, color = "purple", linewidth = 3)
plt.scatter([x0, x1], [y0, y1], color = "black", s = 150)
plt.grid()
plt.axvline(x = 0, color = "black")
plt.axhline(y = 0, color = "black")
plt.xlabel("x")
plt.ylabel("y")
plt.title("No Sign Change: Roots", fontsize = 18)

plt.show()
```

## When Do Functions Have Roots?

:::{.fraction}

Given the images we've seen so far, if we assume that our function is continuous over an interval, then we can find a simple criteria that guarantees the presence of at least one root -- a sign change.

:::

:::{.fragment}

An interval $\left[a, b\right]$ over which a continuous function $f\left(x\right)$ experiences a sign change -- that is, $f\left(a\right)\cdot f\left(b\right) < 0$, is called a ***Bracketed interval***.

:::

:::{.fragment}

Continuous functions must have at least one root along and interval over which they are bracketed.

:::

:::{.fragment}

This will be our foundational starting point.

:::

## Intution for Root Finding

:::{.fragment}

If we know that we have a continuous function and an interval that brackets it, then that function has a root on the interval.

:::

:::{.fragment}

Our process will be as follows:

:::

1. Verify that our function is continous (at least along an interval of interest).
2. Discover a bracketing interval for that function.
3. Use a root-finding method to close in on the location of the root.

## Finding a Bracketing Interval (Incremental Search)

:::{.fragment}

Since you already know how to identify discontinuities of functions, we'll start by identifying a strategy for locating a bracketing interval.

:::

:::{.fragment}

The most straight-forward way to discover a bracketing interval is to use a strategy called ***incremental search***.

:::

::::{.columns}

:::{.column width="60%"}

:::

:::{.column width="40%"}

<div style="font-size:18pt">

:::{.fragment}

The idea is simple...

:::

1. Start from the left end of the interval.
2. Take a small step forward.
3. Check for bracketing.
4. Repeat steps 2 and 3 until a bracketed interval is found or you escape the interval of interest.

</div>

:::

::::

## Finding a Bracketing Interval (Incremental Search)

Since you already know how to identify discontinuities of functions, we'll start by identifying a strategy for locating a bracketing interval.

The most straight-forward way to discover a bracketing interval is to use a strategy called ***incremental search***.

::::{.columns}

:::{.column width="60%"}

```{python}
#@title
x_vals = np.linspace(0, 5, 250)
y_vals = x_vals*np.cos(x_vals)

x0 = 0
y0 = x0*np.cos(x0)
x1 = 0.5
y1 = x1*np.cos(x1)

plt.figure(figsize = (8, 4))
plt.plot(x_vals, y_vals, color = "purple", linewidth = 3)
plt.scatter([x0, x1], [y0, y1], color = "black", s = 100)
plt.scatter([x0], [y0], color = "black", s = 100)
plt.grid()
plt.axhline(y = 0, color = "black")
plt.axvline(x = 0, color = "black")
plt.axvline(x = x0, color = "black", ls = "--")
plt.axvline(x = x1, color = "black", ls = "--")
plt.xlabel("x")
plt.ylabel("y")
plt.title("$f(x) = x*cos(x)$ is not Bracketed")
plt.show()
```

:::

:::{.column width="40%"}

<div style="font-size:18pt">

:::{.nonincremental}

The idea is simple...

1. Start from the left end of the interval.
2. Take a small step forward.
3. Check for bracketing.
4. Repeat steps 2 and 3 until a bracketed interval is found or you escape the interval of interest.

:::

</div>

:::

::::

## Finding a Bracketing Interval (Incremental Search)

Since you already know how to identify discontinuities of functions, we'll start by identifying a strategy for locating a bracketing interval.


The most straight-forward way to discover a bracketing interval is to use a strategy called ***incremental search***.

::::{.columns}

:::{.column width="60%"}

```{python}
x_vals = np.linspace(0, 5, 250)
y_vals = x_vals*np.cos(x_vals)

x0 = 0.5
y0 = x0*np.cos(x0)
x1 = 1
y1 = x1*np.cos(x1)

plt.figure(figsize = (8, 4))
plt.plot(x_vals, y_vals, color = "purple", linewidth = 3)
plt.scatter([x0, x1], [y0, y1], color = "black", s = 100)
plt.scatter([x0], [y0], color = "black", s = 100)
plt.grid()
plt.axhline(y = 0, color = "black")
plt.axvline(x = 0, color = "black")
plt.axvline(x = x0, color = "black", ls = "--")
plt.axvline(x = x1, color = "black", ls = "--")
plt.xlabel("x")
plt.ylabel("y")
plt.title("$f(x) = x*cos(x)$ is not Bracketed")
plt.show()
```

:::

:::{.column width="40%"}

<div style="font-size:18pt">

:::{.nonincremental}

The idea is simple...

1. Start from the left end of the interval.
2. Take a small step forward.
3. Check for bracketing.
4. Repeat steps 2 and 3 until a bracketed interval is found or you escape the interval of interest.

:::

</div>

:::

::::

## Finding a Bracketing Interval (Incremental Search)

Since you already know how to identify discontinuities of functions, we'll start by identifying a strategy for locating a bracketing interval.


The most straight-forward way to discover a bracketing interval is to use a strategy called ***incremental search***.

::::{.columns}

:::{.column width="60%"}

```{python}
x_vals = np.linspace(0, 5, 250)
y_vals = x_vals*np.cos(x_vals)

x0 = 1
y0 = x0*np.cos(x0)
x1 = 1.5
y1 = x1*np.cos(x1)

plt.figure(figsize = (8, 4))
plt.plot(x_vals, y_vals, color = "purple", linewidth = 3)
plt.scatter([x0, x1], [y0, y1], color = "black", s = 100)
plt.scatter([x0], [y0], color = "black", s = 100)
plt.grid()
plt.axhline(y = 0, color = "black")
plt.axvline(x = 0, color = "black")
plt.axvline(x = x0, color = "black", ls = "--")
plt.axvline(x = x1, color = "black", ls = "--")
plt.xlabel("x")
plt.ylabel("y")
plt.title("$f(x) = x*cos(x)$ is not Bracketed")
plt.show()
```

:::

:::{.column width="40%"}

<div style="font-size:18pt">

:::{.nonincremental}

The idea is simple...

1. Start from the left end of the interval.
2. Take a small step forward.
3. Check for bracketing.
4. Repeat steps 2 and 3 until a bracketed interval is found or you escape the interval of interest.

:::

</div>

:::

::::

## Finding a Bracketing Interval (Incremental Search)

Since you already know how to identify discontinuities of functions, we'll start by identifying a strategy for locating a bracketing interval.


The most straight-forward way to discover a bracketing interval is to use a strategy called ***incremental search***.

::::{.columns}

:::{.column width="60%"}

```{python}
x_vals = np.linspace(0, 5, 250)
y_vals = x_vals*np.cos(x_vals)

x0 = 1.5
y0 = x0*np.cos(x0)
x1 = 2
y1 = x1*np.cos(x1)

plt.figure(figsize = (8, 4))
plt.plot(x_vals, y_vals, color = "purple", linewidth = 3)
plt.scatter([x0, x1], [y0, y1], color = "black", s = 100)
plt.scatter([x0], [y0], color = "black", s = 100)
plt.grid()
plt.axhline(y = 0, color = "black")
plt.axvline(x = 0, color = "black")
plt.axvline(x = x0, color = "black", ls = "--")
plt.axvline(x = x1, color = "black", ls = "--")
plt.xlabel("x")
plt.ylabel("y")
plt.title("$f(x) = x*cos(x)$ is Bracketed")
plt.show()
```

:::

:::{.column width="40%"}

<div style="font-size:18pt">

:::{.nonincremental}

The idea is simple...

1. Start from the left end of the interval.
2. Take a small step forward.
3. Check for bracketing.
4. Repeat steps 2 and 3 until a bracketed interval is found or you escape the interval of interest.

:::

</div>

:::

::::

:::{.fragment}

<div style="font-size:18pt">

The function $f\left(x\right) = x\cos\left(x\right)$ is bracketed on the interval $\left[1.5, 2\right]$.

</div>

:::

## An Example (By Hand)

:::{.fragment}

**Example:** Given the function $f\left(x\right) = x^2 - 3x + 1$, use *incremental search* over the interval $\left[0, 1\right]$ with $dx = 0.2$ to determine whether a root may exist on the interval.

:::

## Comments on Incremental Search

<div style="font-size:18pt">

+ The result of incremental search is a bracketed interval of the form $\left[x_1, x_2\right]$ within which a root of the function exists.
+ The step size used determines the width of the bracketed interval returned.

  + Using a very small step size returns a very narrow interval.
  + Using a very large step size returns a very wide interval, or may even skip over the root altogether!

+ Using extremely small step sizes is not efficient and may cause incremental search to run for a very large number of iterations before finding the bracketed interval.

  + This may be unacceptable.
  + There are much faster methods for converging on the root once we know we have a bracketed interval anyway.

+ Your goal with incremental search should simply be to find a bracketed interval and then move on to a more efficient root-finding method to close in.

</div>

## Implementing Incremental Search

<div style="font-size:18pt">

```{python}
#| echo: true
#| eval: true

def incrementalSearch(f, a, b, dx):
  #Write the Incremental Search function here.
  x1 = a
  x2 = x1 + dx

  while (np.sign(f(x1)) == np.sign(f(x2))) and (x2 <= b):
    x1 = x2
    x2 = x1 + dx

  if np.sign(f(x1)) != np.sign(f(x2)):
    return [x1, x2]

  print("I didn't find a bracketed interval.")
  return None
```

:::{.fragment}

**Example 1:** Use the `incrementalSearch()` routine on the interval $\left[0, 2\right]$ with $f\left(x\right) = x\cdot\cos\left(x\right)$ and $dx = 0.1$.

:::

:::{.fragment}

**Example 2:** Use `incrementalSearch()` to find the root of the function $\displaystyle{f\left(x\right) = \frac{x^2 - 9}{x + 4}e^x - 10\sin\left(x\right)}$ which lies on the interval $\left[0, 5\right]$.

:::

</div>

## Increasing Accuracy

:::{.fragment}

We'll find better methods for closing in on the location of a root. However, it is possible to close in using `incrementalSearch()` by using progressively smaller step sizes on the bracketed intervals being found.

:::

::::{.columns}

:::{.column width="50%"}

:::{.fragment}

```{python}
#| echo: true
#| eval: true

def f(x):
  return x*np.cos(x)

x1 = 0.1
x2 = 2

tic = time.time()

for i in range(6):
  dx = 0.1**(i+1)
  x1, x2 = incrementalSearch(f, x1, x2, dx)

toc = time.time()

print(x1, x2)
print("That took ", toc - tic, " seconds")
```

:::

:::

:::{.column width="50%"}

:::{.fragment}

```{python}
#| echo: true
#| eval: true

def f(x):
  return x*np.cos(x)

x1 = 0.1
x2 = 2
dx = 0.000001

tic = time.time()

x1, x2 = incrementalSearch(f, x1, x2, dx)

toc = time.time()

print(x1, x2)
print("That took ", toc - tic, " seconds")
```

:::

:::

::::

## Closing in on a Root: Bisection

<div style="font-size:18pt">

:::{.fragment}

We'll find multiple methods for closing in on the root of a function once we have a bracketed interval for it.

:::

:::{.fragment}

Our first method is the simplest and is reasonably effective. 

:::

:::{.fragment}

Using the method of ***Bisection***, we find the midpoint of our bracketed interval, evaluate the function at both endpoints and the midpoint, identify which subinterval remains bracketed, and then shrink down to that subinterval.

:::

:::{.fragment}

We continue doing this until (i) we obtain a function value of exactly $0$, or (ii) the resulting subinterval is smaller than some pre-set tolerance for error.

:::

:::{.fragment}

If we reach this second condition, then we compute the midpoint once more and report that value as the numerical approximation of the root.

:::

:::{.fragment}

**Example:** The function $\displaystyle{f\left(x\right) = x^2 - 5x + 3}$ has a root on the interval $\left[0, 2\right]$. Verify that this interval is bracketed, and then carry out four iterations of the bisection method to approximate the value of the root. Determine the level of accuracy that you've obtained through this procedure.

:::

</div>

## Implementing Bisection

::::{.columns}

:::{.column width="50%"}

<div style="font-size:17pt">

```{python}
#| echo: true
#| eval: true

def bisection(f, x1, x2, tol = 1.0e-9):
  dx = x2 - x1
  y1 = f(x1)
  y2 = f(x2)

  if np.sign(y1) == np.sign(y2):
    print("The interval [x1, x2] is not bracketed. \nPlease provide a bracketed interval to start.")
    return None

  while dx > tol:
    x3 = (x1 + x2)/2
    y3 = f(x3)

    if np.sign(y1) == np.sign(y3):
      x1 = x3
    else:
      x2 = x3

    y1 = f(x1)
    y2 = f(x2)
    dx = dx/2

  x = (x1 + x2)/2
  return x
```

</div>

:::

:::{.column width="50%"}

<div style="font-size:16pt">

:::{.fragment}

**Example:** Use our Bisection function to approximate the root of the function $f\left(x\right) = x\cdot \cos\left(x\right)$ in the bracketed interval $\left[1, 2\right]$.

:::

:::{.fragment}

**Example:** Use `bisection` to find the root of the function $f\left(x\right) = \frac{x^2 - 9}{x + 4}e^x - 10\sin\left(x\right)$ which lies on the interval $\left[2, 4\right]$.

:::

</div>

:::{.fragment}

<div style="font-size:16pt">

**Example:** The natural frequencies of a uniform cantilever beam are related to the roots $\beta_i$ of the frequency equation $f\left(\beta\right) = \cosh\left(\beta\right)\cos\left(\beta\right) + 1$, where

</div>

<div style="font-size:14pt">

\begin{align*} \beta_i^4 &= \left(2\pi f_i\right)^2\frac{\tt{m}\tt{L}^3}{\tt{E}\tt{I}}\\
f_i &= i^{th}~\text{natural frequency ($\tt{cps}$)}\\
m &= ~\text{mass of the beam}\\
L &= ~\text{Length of the beam}\\
E &= ~\text{modulus of elasticity}\\
I &= ~\text{moment of inertia of the cross section} = \displaystyle{\frac{1}{12}\left(\text{width}\right)\left(\text{height}^3\right)}
\end{align*}

</div>

:::

:::

::::

:::{.fragment}

<div style="font-size:16pt">

Determine the lowest two frequencies of a steel beam $0.9~\tt{m}$ long, with rectangular cross-sections $25~\tt{mm}$ wide and $2.5~\tt{mm}$ high. The mass-density of steel is $7580~\tt{kg/m}^3$ and $E = 200~\text{GPa}$.

</div>

:::

## Summary

+ In this notebook, we introduced and implemented the method of *incremental search* for locating *bracketed intervals*, and also the *bisection method* for quickly closing in on the location of a root on the interior of a bracketed interval. 
+ These techniques can be utilized to solve equations of the form $f\left(x\right) = 0$ for any function given some initial search interval.

:::{.fragment}

**Next Time:** In the next notebook we'll look at series of techniques called *linear interpolation* which complement the bisection method we encountered here.

:::


